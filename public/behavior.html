<!DOCTYPE html>
<html>
  <head>
    <title>Java to Python</title>
      <link rel="stylesheet" href="/stylesheets/style.css">
      <link rel="stylesheet" href="/stylesheets/info.css">
  </head>
  <body>
    <div id="header">
      <div id="logo">
        <h1><a href="/">Java to Python</a></h1>
      </div>
      <div id="nav-bar">
        <ul>
          <li id="about"><a href="">About</a></li>
          <li id="behavior"><a href="/behavior">Behavior</a></li>
        </ul>
      </div>
    </div>
    <div id="container">
      <h1>Compiler Behavior</h1>
      <ul id="table-of-contents">
        <li><a href="#classes">Classes</a></li>
        <li><a href="#variables">Variables</a></li>
        <li><a href="#methods">Methods</a></li>
        <li><a href="#constructors">Constructors</a></li>
        <li><a href="#arrays">Arrays</a></li>
      </ul>

      <h2 id="classes">Classes</h2>
      <p>Typically, Java classes translate fairly straightforward into
      Python code.
      </p>

      <h3>Inheritance</h3>
      <p>Because Java does not support multiple inheritance, the 
      resulting Python code will only have one superclass. As of now, 
      interfaces are not supported.</p>
      
      <div class="code-example">
<pre class="java">public class HelloWorld extends Example {
    // body
}</pre>
<pre class="python">class HelloWorld(Example):
    pass
</pre>
      </div>
      
      <h3>Modifiers</h3>
      <p>Certain Java modifiers are treated differently by the compiler.
      Some modifiers are implicitly translated (such as <tt>static</tt>);
      other modifiers are ignored completely. Here is a list of
      modifiers:</p>
      
      <ul>
        <li><tt>public</tt>, <tt>private</tt>, <tt>protected</tt>: 
        ignored</li>
        <li><tt>static</tt>: implicit for variables, ignored for methods
        </li>
      </ul>
      
      <h2 id="variables">Variables</h2>
      <p>Java's three types of variables -- local, instance, and static 
      -- translate directly into their Python counterparts (static 
      variables become class variables).
      </p>
      
      <h3>Class/static Variables</h3>
      <p>Class variable declarations are the first block of code 
      following the class signature. If a static variable is not 
      initialized, only declared, then it will not appear in the Python 
      code (since Python does not require variable declarations).</p>
      
      <div class="code-example">
<pre class="java">class Ex {
    static int x = 4, y;
}</pre>
<pre class="python">class Ex(object):
    x = 4
</pre>
      </div>
      
      <p>In methods, class variables are referred to by using dot 
      notation in conjuction with the class name:</p>
      <div class="code-example">
<pre class="java">class Ex {
    static int x = 4, y;
    int foo() {
        y = x + 5;
        return y;
    }
}</pre>
<pre class="python">class Ex(object):
    x = 4

    def foo(self):
        Ex.y = Ex.x + 5
        return Ex.y
</pre>
      </div>
      
      <h3>Instance variables</h3>
      <p>Instance variables are declared inside of the <tt>__init__</tt>
      method of the Python class (equivalent to Java's constructors).
      They are always referred to preceded by <tt>self.</tt> As with
      class variables, if an instance variable is not initialized, it
      will not be present in the Python code's constructor.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int x = 3, y;
    int foo() {
        y = x + 3;
        return y;
    }
}</pre>
<pre class="python">class Ex(object):
    def __init__(self):
        self.x = 3

    def foo(self):
        self.y = self.x + 3
        return self.y
</pre>
      </div>

      <h3>Local variables</h3>
      <p>Local variables remain the way they are, without any dot
      expressions preceding them.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int foo() {
        int y = 4 + 5;
        return y;
    }
}</pre>
<pre class="python">class Ex(object):
    def foo(self):
        y = 4 + 5
        return y
</pre>
      </div>

      <h2 id="methods">Methods</h2>
      <p>Methods will always take at least one argument in Python -- the
      first argument is always <tt>self</tt>.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int foo(int a, String b) {
        return a;
    }
}</pre>
<pre class="python">class Ex(object):
    def foo(self, a, b):
        return a
</pre>
      </div>
      <p>The tricky part about compiling Java to Python is method
      overloading. In Python, methods cannot be overloaded because they
      will collide in the class's namespace. One workaround takes
      advantage of Python's star (*) notation, which allows functions
      to take in an arbitrary number of arguments.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int foo() {
        return 3;
    }
    int foo(int x) {
        return x;
    }
    int foo(int z, int y) {
        return z + y;
    }
}</pre>
<pre class="python">class Ex(object):
    def foo(self, *args):
        if len(args) == 0:
        return 3
    elif len(args) == 1:
        (x,) = args
        return x
    elif len(args) == 2:
        (z, y,) = args
        return z + y</pre>
      </div>
      <p>Notice that the arguments for each overloaded method are
      unpacked into parameters that correspond to their Java 
      counterparts.</p>
      
      <h2 id="constructors">Constructors</h2>
      <p>Constructors are written into the <tt>__init__</tt> method,
      after any instance variable declarations. Constructor overloading
      is resolved just like method overloading.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int x = 4, y;
    Ex() {
        y = 5;
    }
    Ex(int y) {
        this.y = y;
    }
}</pre>
<pre class="python">class Ex(object):
    def __init__(self, *args):
        self.x = 4
        if len(args) == 0:
            self.y = 5
        elif len(args) == 1:
            (y,) = args
            self.y = y</pre>
      </div>
      
      <h2 id="arrays">Arrays</h2>
      <p>Array 'literals' are converted into Python lists.</p>
      <div class="code-example">
<pre class="java">class Ex {
    int[] x = {1, 2, 3, 4};
}</pre>
<pre class="python">class Ex(object):
    def __init__(self, *args):
        self.x = [1, 2, 3, 4]</pre>
      </div>
      
      <p>Array constructors are converted into Python list
      comprehensions. The default element depends on the datatype of the
      array:</p>
      <div class="code-example">
<pre class="java">class Ex {
    int[] x = new int[3];
    boolean[] b = new boolean[2][3];
    String s[] = new String[3];
}</pre>
<pre class="python">class Ex(object):
    def __init__(self, *args):
        self.x = [0 for _ in range(3)]
        self.b = [[False for _ in range(3)] for _ in range(2)]
        self.s = [None for _ in range(3)]
</pre>
      </div>
    </div>
  </body>
</html>
